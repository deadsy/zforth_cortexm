//-----------------------------------------------------------------------------
/*

   MB997C Board

 */
//-----------------------------------------------------------------------------

#include <string.h>

#include "stm32f4_soc.h"
#include "debounce.h"
#include "utils.h"
#include "io.h"
#include "zforth.h"

#define DEBUG
#include "logging.h"

//-----------------------------------------------------------------------------

static const uint8_t zf_dict[1099] = {
	0x4b, 0x04, 0x00, 0x00, 0x39, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x65, 0x78, 0x69, 0x74, 0x00, 0x00, 0x23, 0x14, 0x6c, 0x69,
	0x74, 0x01, 0x00, 0x22, 0x1c, 0x3c, 0x30, 0x02, 0x00, 0x21, 0x23, 0x3a, 0x03, 0x00, 0x61, 0x29,
	0x3b, 0x04, 0x00, 0x21, 0x2e, 0x2b, 0x05, 0x00, 0x21, 0x33, 0x2d, 0x06, 0x00, 0x21, 0x38, 0x2a,
	0x07, 0x00, 0x21, 0x3d, 0x2f, 0x08, 0x00, 0x21, 0x42, 0x25, 0x09, 0x00, 0x24, 0x47, 0x64, 0x72,
	0x6f, 0x70, 0x0a, 0x00, 0x23, 0x4c, 0x64, 0x75, 0x70, 0x0b, 0x00, 0x25, 0x54, 0x70, 0x69, 0x63,
	0x6b, 0x72, 0x0c, 0x00, 0x69, 0x5b, 0x69, 0x6d, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x74, 0x65, 0x0d,
	0x00, 0x22, 0x64, 0x40, 0x40, 0x0e, 0x00, 0x22, 0x71, 0x21, 0x21, 0x0f, 0x00, 0x24, 0x77, 0x73,
	0x77, 0x61, 0x70, 0x10, 0x00, 0x23, 0x7d, 0x72, 0x6f, 0x74, 0x11, 0x00, 0x23, 0x80, 0x85, 0x6a,
	0x6d, 0x70, 0x12, 0x00, 0x24, 0x80, 0x8c, 0x6a, 0x6d, 0x70, 0x30, 0x13, 0x00, 0x21, 0x80, 0x94,
	0x27, 0x14, 0x00, 0x61, 0x80, 0x9d, 0x28, 0x15, 0x00, 0x22, 0x80, 0xa3, 0x3e, 0x72, 0x16, 0x00,
	0x22, 0x80, 0xa9, 0x72, 0x3e, 0x17, 0x00, 0x21, 0x80, 0xb0, 0x3d, 0x18, 0x00, 0x23, 0x80, 0xb7,
	0x73, 0x79, 0x73, 0x19, 0x00, 0x24, 0x80, 0xbd, 0x70, 0x69, 0x63, 0x6b, 0x1a, 0x00, 0x22, 0x80,
	0xc5, 0x2c, 0x2c, 0x1b, 0x00, 0x23, 0x80, 0xce, 0x6b, 0x65, 0x79, 0x1c, 0x00, 0x24, 0x80, 0xd5,
	0x6c, 0x69, 0x74, 0x73, 0x1d, 0x00, 0x22, 0x80, 0xdd, 0x23, 0x23, 0x1e, 0x00, 0x21, 0x80, 0xe6,
	0x26, 0x1f, 0x00, 0x01, 0x80, 0xed, 0x68, 0x01, 0x00, 0x00, 0x06, 0x80, 0xf3, 0x6c, 0x61, 0x74,
	0x65, 0x73, 0x74, 0x01, 0x01, 0x00, 0x05, 0x80, 0xfa, 0x74, 0x72, 0x61, 0x63, 0x65, 0x01, 0x02,
	0x00, 0x09, 0x81, 0x06, 0x63, 0x6f, 0x6d, 0x70, 0x69, 0x6c, 0x69, 0x6e, 0x67, 0x01, 0x03, 0x00,
	0x09, 0x81, 0x11, 0x5f, 0x70, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x6e, 0x65, 0x01, 0x04, 0x00, 0x04,
	0x81, 0x20, 0x65, 0x6d, 0x69, 0x74, 0x01, 0x00, 0x19, 0x00, 0x01, 0x81, 0x2f, 0x2e, 0x01, 0x01,
	0x19, 0x00, 0x04, 0x81, 0x3a, 0x74, 0x65, 0x6c, 0x6c, 0x01, 0x02, 0x19, 0x00, 0x04, 0x81, 0x42,
	0x64, 0x75, 0x6d, 0x70, 0x01, 0x80, 0x80, 0x19, 0x00, 0x01, 0x81, 0x4d, 0x21, 0x01, 0x00, 0x0f,
	0x00, 0x01, 0x81, 0x59, 0x40, 0x01, 0x00, 0x0e, 0x00, 0x01, 0x81, 0x61, 0x2c, 0x01, 0x00, 0x1b,
	0x00, 0x01, 0x81, 0x69, 0x23, 0x01, 0x00, 0x1e, 0x00, 0x41, 0x81, 0x71, 0x5b, 0x01, 0x00, 0x81,
	0x1d, 0x81, 0x5d, 0x00, 0x01, 0x81, 0x79, 0x5d, 0x01, 0x01, 0x81, 0x1d, 0x81, 0x5d, 0x00, 0x48,
	0x81, 0x84, 0x70, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x6e, 0x65, 0x01, 0x01, 0x81, 0x2c, 0x81, 0x5d,
	0x00, 0x04, 0x81, 0x8f, 0x6f, 0x76, 0x65, 0x72, 0x01, 0x01, 0x1a, 0x00, 0x02, 0x81, 0xa1, 0x2b,
	0x21, 0x0b, 0x81, 0x65, 0x11, 0x05, 0x10, 0x81, 0x5d, 0x00, 0x03, 0x81, 0xac, 0x69, 0x6e, 0x63,
	0x01, 0x01, 0x10, 0x81, 0xb1, 0x00, 0x03, 0x81, 0xba, 0x64, 0x65, 0x63, 0x01, 0xff, 0xff, 0xff,
	0xff, 0xff, 0x10, 0x81, 0xb1, 0x00, 0x01, 0x81, 0xc6, 0x3c, 0x06, 0x02, 0x00, 0x01, 0x81, 0xd6,
	0x3e, 0x10, 0x81, 0xda, 0x00, 0x02, 0x81, 0xdd, 0x3c, 0x3d, 0x81, 0xa8, 0x81, 0xa8, 0x16, 0x16,
	0x81, 0xda, 0x17, 0x17, 0x18, 0x05, 0x00, 0x02, 0x81, 0xe5, 0x3e, 0x3d, 0x10, 0x81, 0xea, 0x00,
	0x02, 0x81, 0xf7, 0x3d, 0x30, 0x01, 0x00, 0x18, 0x00, 0x03, 0x82, 0x00, 0x6e, 0x6f, 0x74, 0x82,
	0x05, 0x00, 0x02, 0x82, 0x09, 0x21, 0x3d, 0x18, 0x82, 0x0f, 0x00, 0x02, 0x82, 0x12, 0x63, 0x72,
	0x01, 0x0a, 0x81, 0x36, 0x00, 0x02, 0x82, 0x1b, 0x2e, 0x2e, 0x0b, 0x81, 0x3e, 0x00, 0x04, 0x82,
	0x25, 0x68, 0x65, 0x72, 0x65, 0x80, 0xf7, 0x81, 0x65, 0x00, 0x05, 0x82, 0x2e, 0x61, 0x6c, 0x6c,
	0x6f, 0x74, 0x80, 0xf7, 0x81, 0xb1, 0x00, 0x03, 0x82, 0x3a, 0x76, 0x61, 0x72, 0x03, 0x81, 0x7d,
	0x14, 0x01, 0x81, 0x6d, 0x82, 0x35, 0x0b, 0x01, 0x05, 0x05, 0x81, 0x6d, 0x14, 0x00, 0x81, 0x6d,
	0x82, 0x35, 0x10, 0x81, 0x5d, 0x01, 0x05, 0x82, 0x42, 0x00, 0x45, 0x82, 0x47, 0x62, 0x65, 0x67,
	0x69, 0x6e, 0x82, 0x35, 0x00, 0x45, 0x82, 0x6a, 0x61, 0x67, 0x61, 0x69, 0x6e, 0x14, 0x12, 0x81,
	0x6d, 0x81, 0x6d, 0x00, 0x45, 0x82, 0x75, 0x75, 0x6e, 0x74, 0x69, 0x6c, 0x14, 0x13, 0x81, 0x6d,
	0x81, 0x6d, 0x00, 0x45, 0x82, 0x84, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x14, 0x01, 0x01, 0x06, 0x81,
	0x6d, 0x14, 0x0b, 0x81, 0x6d, 0x14, 0x82, 0x05, 0x81, 0x6d, 0x82, 0x8c, 0x00, 0x42, 0x82, 0x93,
	0x69, 0x66, 0x14, 0x13, 0x81, 0x6d, 0x82, 0x35, 0x01, 0x83, 0xe7, 0x81, 0x6d, 0x00, 0x46, 0x82,
	0xad, 0x75, 0x6e, 0x6c, 0x65, 0x73, 0x73, 0x14, 0x82, 0x0f, 0x81, 0x6d, 0x82, 0xb2, 0x00, 0x44,
	0x82, 0xbe, 0x65, 0x6c, 0x73, 0x65, 0x14, 0x12, 0x81, 0x6d, 0x82, 0x35, 0x01, 0x83, 0xe7, 0x81,
	0x6d, 0x10, 0x82, 0x35, 0x10, 0x81, 0x5d, 0x00, 0x42, 0x82, 0xcf, 0x66, 0x69, 0x82, 0x35, 0x10,
	0x81, 0x5d, 0x00, 0x41, 0x82, 0xe8, 0x69, 0x14, 0x01, 0x81, 0x6d, 0x01, 0x00, 0x81, 0x6d, 0x14,
	0x0c, 0x81, 0x6d, 0x00, 0x41, 0x82, 0xf3, 0x6a, 0x14, 0x01, 0x81, 0x6d, 0x01, 0x02, 0x81, 0x6d,
	0x14, 0x0c, 0x81, 0x6d, 0x00, 0x42, 0x83, 0x04, 0x64, 0x6f, 0x14, 0x10, 0x81, 0x6d, 0x14, 0x16,
	0x81, 0x6d, 0x14, 0x16, 0x81, 0x6d, 0x82, 0x35, 0x00, 0x45, 0x83, 0x15, 0x6c, 0x6f, 0x6f, 0x70,
	0x2b, 0x14, 0x17, 0x81, 0x6d, 0x14, 0x05, 0x81, 0x6d, 0x14, 0x0b, 0x81, 0x6d, 0x14, 0x16, 0x81,
	0x6d, 0x14, 0x01, 0x81, 0x6d, 0x01, 0x01, 0x81, 0x6d, 0x14, 0x0c, 0x81, 0x6d, 0x14, 0x81, 0xe1,
	0x81, 0x6d, 0x14, 0x13, 0x81, 0x6d, 0x81, 0x6d, 0x14, 0x17, 0x81, 0x6d, 0x14, 0x0a, 0x81, 0x6d,
	0x14, 0x17, 0x81, 0x6d, 0x14, 0x0a, 0x81, 0x6d, 0x00, 0x44, 0x83, 0x29, 0x6c, 0x6f, 0x6f, 0x70,
	0x14, 0x01, 0x81, 0x6d, 0x01, 0x01, 0x81, 0x6d, 0x83, 0x31, 0x00, 0x42, 0x83, 0x69, 0x73, 0x22,
	0x81, 0x1d, 0x81, 0x65, 0x13, 0x83, 0x91, 0x14, 0x1d, 0x81, 0x6d, 0x82, 0x35, 0x01, 0x00, 0x81,
	0x6d, 0x82, 0x35, 0x1c, 0x0b, 0x01, 0x22, 0x18, 0x13, 0x83, 0xb6, 0x0a, 0x81, 0x1d, 0x81, 0x65,
	0x13, 0x83, 0xad, 0x82, 0x35, 0x10, 0x06, 0x10, 0x81, 0x5d, 0x12, 0x83, 0xb2, 0x0b, 0x82, 0x35,
	0x10, 0x06, 0x00, 0x12, 0x83, 0xb8, 0x81, 0x6d, 0x12, 0x83, 0x93, 0x00, 0x42, 0x83, 0x7b, 0x2e,
	0x22, 0x81, 0x1d, 0x81, 0x65, 0x13, 0x83, 0xd2, 0x83, 0x80, 0x14, 0x81, 0x49, 0x81, 0x6d, 0x12,
	0x83, 0xe4, 0x1c, 0x0b, 0x01, 0x22, 0x18, 0x13, 0x83, 0xdf, 0x0a, 0x00, 0x12, 0x83, 0xe1, 0x81,
	0x36, 0x12, 0x83, 0xd2, 0x00, 0x04, 0x83, 0xbc, 0x6e, 0x65, 0x78, 0x74, 0x0b, 0x81, 0x75, 0x05,
	0x00, 0x04, 0x83, 0xe5, 0x6e, 0x61, 0x6d, 0x65, 0x0b, 0x81, 0x65, 0x01, 0x1f, 0x1f, 0x10, 0x83,
	0xec, 0x0b, 0x83, 0xec, 0x11, 0x81, 0x49, 0x81, 0x65, 0x00, 0x05, 0x83, 0xf1, 0x77, 0x6f, 0x72,
	0x64, 0x73, 0x81, 0x03, 0x81, 0x65, 0x83, 0xf8, 0x01, 0x20, 0x81, 0x36, 0x0b, 0x01, 0x00, 0x18,
	0x13, 0x84, 0x16, 0x82, 0x20, 0x0a, 0x00, 0x03, 0x84, 0x0a, 0x6d, 0x61, 0x78, 0x81, 0xa8, 0x81,
	0xa8, 0x81, 0xda, 0x13, 0x84, 0x37, 0x10, 0x0a, 0x00, 0x03, 0x84, 0x27, 0x6d, 0x69, 0x6e, 0x81,
	0xa8, 0x81, 0xa8, 0x81, 0xe1, 0x13, 0x84, 0x49, 0x10, 0x0a, 0x00,
};

//-----------------------------------------------------------------------------
// IO configuration

static const struct gpio_info gpios[] = {
	// leds
	{IO_LED_RED, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_LED_BLUE, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_LED_GREEN, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_LED_AMBER, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	// push buttons
	{IO_PUSH_BUTTON, GPIO_MODER_IN, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	// serial port (usart2 function)
	{IO_UART_TX, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_HI, GPIO_PUPD_NONE, GPIO_AF7, 0},
	{IO_UART_RX, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_HI, GPIO_PUPD_NONE, GPIO_AF7, 0},
	// display
#if defined(SPI_DRIVER_HW)
	{IO_LCD_SDO, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF5, 0},
	{IO_LCD_SCK, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF5, 0},
	{IO_LCD_SDI, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF5, 0},
#elif defined(SPI_DRIVER_BITBANG)
	{IO_LCD_SDO, GPIO_MODER_IN, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_LCD_SCK, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_LCD_SDI, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF0, 0},
#else
#error "what kind of SPI driver are we building?"
#endif
	{IO_LCD_DATA_CMD, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF0, 1},
	{IO_LCD_RESET, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 1},
	{IO_LCD_CS, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF0, 1},
	{IO_LCD_LED, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	// audio
	{IO_AUDIO_RESET, GPIO_MODER_OUT, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_AUDIO_I2C_SCL, GPIO_MODER_IN, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_AUDIO_I2C_SDA, GPIO_MODER_IN, GPIO_OTYPER_PP, GPIO_OSPEEDR_LO, GPIO_PUPD_NONE, GPIO_AF0, 0},
	{IO_AUDIO_I2S_MCK, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF6, 0},
	{IO_AUDIO_I2S_SCK, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF6, 0},
	{IO_AUDIO_I2S_SD, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF6, 0},
	{IO_AUDIO_I2S_WS, GPIO_MODER_AF, GPIO_OTYPER_PP, GPIO_OSPEEDR_FAST, GPIO_PUPD_NONE, GPIO_AF6, 0},
};

//-----------------------------------------------------------------------------

#ifdef USE_FULL_ASSERT
void assert_failed(uint8_t * file, uint32_t line) {
	while (1);
}
#endif

void Error_Handler(void) {
	while (1);
}

//-----------------------------------------------------------------------------

void NMI_Handler(void) {
}
void HardFault_Handler(void) {
	while (1);
}
void MemManage_Handler(void) {
	while (1);
}
void BusFault_Handler(void) {
	while (1);
}
void UsageFault_Handler(void) {
	while (1);
}
void SVC_Handler(void) {
}
void DebugMon_Handler(void) {
}
void PendSV_Handler(void) {
}

void SysTick_Handler(void) {
	uint32_t ticks = HAL_GetTick();
	// blink the green led every 512 ms
	if ((ticks & 511) == 0) {
		gpio_toggle(IO_LED_GREEN);
	}
	// sample debounced inputs every 16 ms
	if ((ticks & 15) == 0) {
		debounce_isr();
	}
	HAL_IncTick();
}

//-----------------------------------------------------------------------------

static void SystemClock_Config(void) {
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_OscInitTypeDef RCC_OscInitStruct;

	// Enable Power Control clock
	__PWR_CLK_ENABLE();

	// The voltage scaling allows optimizing the power consumption when the device is
	// clocked below the maximum system frequency, to update the voltage scaling value
	// regarding system frequency refer to product datasheet.
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

	// Enable HSE Oscillator and activate PLL with HSE as source
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 8;
	RCC_OscInitStruct.PLL.PLLN = 336;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 7;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
		Error_Handler();
	}
	// Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers
	RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) {
		Error_Handler();
	}
}

//-----------------------------------------------------------------------------
// key debouncing (called from the system tick isr)

#define PUSH_BUTTON_BIT 0

// handle a key down
void debounce_on_handler(uint32_t bits) {
	if (bits & (1 << PUSH_BUTTON_BIT)) {
		//event_wr(EVENT_TYPE_KEY_DN | 0U, NULL);
	}
}

// handle a key up
void debounce_off_handler(uint32_t bits) {
	if (bits & (1 << PUSH_BUTTON_BIT)) {
		//event_wr(EVENT_TYPE_KEY_UP | 0U, NULL);
	}
}

// map the gpio inputs to be debounced into the 32 bit debounce state
uint32_t debounce_input(void) {
	return gpio_rd(IO_PUSH_BUTTON) << PUSH_BUTTON_BIT;
}

//-----------------------------------------------------------------------------
// console port (on USART2)

struct usart_cfg serial_cfg = {
	.base = USART2_BASE,
	.baud = 115200,
	.data = 8,
	.parity = 0,
	.stop = 1,
};

struct usart_drv serial_drv;

void USART2_IRQHandler(void) {
	usart_isr(&serial_drv);
}

//-----------------------------------------------------------------------------

// dump_dict dumps the forth dictionary
static void dump_dict(void) {
	void *p = zf_dump(NULL);
	zf_addr len = *((zf_addr *)p);
	printf("static uint8_t zf_dict[%ld] = {\n", len);
	zf_addr i = 0;
	while (i < len) {
		printf("0x%02x,", ((uint8_t *)p)[i]);
		if ((i & 15) == 15) {
			printf("\n");
		}
		i++;
	}
	if ((i & 15) != 0) {
		printf("\n");
	}
	printf("};\n");
}

static int load_dict(const uint8_t *dict, size_t n) {
	size_t len;
	void *p = zf_dump(&len);
	if (n > len) {
		return -1;
	}
	memcpy(p, (void *)dict, n);
	return 0;
}

//-----------------------------------------------------------------------------



static const char *abort_msg[] = {
	"ok", // ZF_OK,
	"internal error", // ZF_ABORT_INTERNAL_ERROR,
	"outside memory", // ZF_ABORT_OUTSIDE_MEM,
	"dstack underrun", // ZF_ABORT_DSTACK_UNDERRUN,
	"dstack overrun", // ZF_ABORT_DSTACK_OVERRUN,
	"rstack underrun", // ZF_ABORT_RSTACK_UNDERRUN,
	"rstack overrun", // ZF_ABORT_RSTACK_OVERRUN,
	"not a word", // ZF_ABORT_NOT_A_WORD,
	"compile-only word", // ZF_ABORT_COMPILE_ONLY_WORD,
	"invalid size", // ZF_ABORT_INVALID_SIZE,
	"division by zero", // ZF_ABORT_DIVISION_BY_ZERO
};

#define ABORT_MSG_MAX (sizeof(abort_msg) / sizeof(const char *))

static zf_result do_eval(const char *buf) {
	zf_result rv = zf_eval(buf);
	if (rv != ZF_OK) {
		if (rv < ABORT_MSG_MAX) {
			fprintf(stderr, "%s\n", abort_msg[rv]);
		} else {
			fprintf(stderr, "unknown error: %d\n", rv);
		}
	}
	return rv;
}

zf_cell zf_host_parse_num(const char *buf) {
	zf_cell v;
	int r = sscanf(buf, ZF_CELL_FMT, &v);
	if (r == 0) {
		zf_abort(ZF_ABORT_NOT_A_WORD);
	}
	return v;
}

zf_input_state zf_host_sys(zf_syscall_id id, const char *input) {
	(void)input;

	switch ((int)id) {
	case ZF_SYSCALL_EMIT:
		putchar((char)zf_pop());
		fflush(stdout);
		break;
	case ZF_SYSCALL_PRINT:
		printf(ZF_CELL_FMT " ", zf_pop());
		break;
	case ZF_SYSCALL_TELL: {
		zf_cell len = zf_pop();
		void *buf = (uint8_t *)zf_dump(NULL) + (int)zf_pop();
		(void)fwrite(buf, 1, len, stdout);
		fflush(stdout);
		break;
	}
	// Application specific callbacks
	case ZF_SYSCALL_USER + 0:
		dump_dict();
		break;
	default:
		printf("unhandled syscall %d\n", id);
		break;
	}
	return ZF_INPUT_INTERPRET;
}

int SEGGER_RTT_vprintf(unsigned BufferIndex, const char *sFormat, va_list * pParamList);

void zf_host_trace(const char *fmt, va_list va) {
	SEGGER_RTT_vprintf(0, fmt, &va);
	SEGGER_RTT_WriteString(0, "\n");
}

//-----------------------------------------------------------------------------

int main(void) {
	int rc;

	HAL_Init();
	SystemClock_Config();

	rc = log_init();
	if (rc != 0) {
		goto exit;
	}

	rc = gpio_init(gpios, sizeof(gpios) / sizeof(struct gpio_info));
	if (rc != 0) {
		DBG("gpio_init failed %d", rc);
		goto exit;
	}

	rc = debounce_init();
	if (rc != 0) {
		DBG("debounce_init failed %d", rc);
		goto exit;
	}

	rc = usart_init(&serial_drv, &serial_cfg);
	if (rc != 0) {
		DBG("usart_init failed %d", rc);
		goto exit;
	}
	// setup the interrupts for the serial port
	HAL_NVIC_SetPriority(USART2_IRQn, 10, 0);
	NVIC_EnableIRQ(USART2_IRQn);

	// initialize zforth
	zf_init(1);
	rc = load_dict(zf_dict, sizeof(zf_dict));
	if (rc != 0) {
		DBG("load_dict failed %d", rc);
		goto exit;
	}

	DBG("init good");

	zf_eval("cr .\" Welcome to zForth Cortex-M, \" here . .\" bytes used\" cr");

	for (;;) {
		char buf[256];
		if (fgets(buf, sizeof(buf), stdin)) {
			do_eval(buf);
		} else {
			break;
		}
	}

exit:
	while (1);
	return 0;
}

//-----------------------------------------------------------------------------
